import { readFile, writeFile, mkdir, rm } from 'node:fs/promises'
import { resolve, dirname } from 'node:path'
import { fileURLToPath } from 'node:url'

const __dirname = dirname(fileURLToPath(import.meta.url))
const rootDir = resolve(__dirname, '..')

interface RuleException {
  files: string[]
  severity: string | number
  options?: unknown[]
}

interface RuleEntry {
  enabled: boolean
  severity: string | number
  options?: unknown[]
  files?: string[]
  exceptions?: RuleException[]
}

const rulesPath = resolve(rootDir, 'rules.json')
const rules = JSON.parse(await readFile(rulesPath, 'utf-8')) as Record<string, RuleEntry>

function getDocUrl(rule: string): string | null {
  const urlMap: Record<string, (name: string) => string> = {
    '@eslint-community/eslint-comments': (name) =>
      `https://eslint-community.github.io/eslint-plugin-eslint-comments/rules/${name}.html`,
    '@graphql-eslint': (name) => `https://the-guild.dev/graphql/eslint/rules/${name}`,
    '@typescript-eslint': (name) => `https://typescript-eslint.io/rules/${name}/`,
    'import-x': (name) =>
      `https://github.com/un-ts/eslint-plugin-import-x/blob/master/docs/rules/${name}.md`,
    jest: (name) =>
      `https://github.com/jest-community/eslint-plugin-jest/blob/main/docs/rules/${name}.md`,
    jsonc: (name) => `https://ota-meshi.github.io/eslint-plugin-jsonc/rules/${name}.html`,
    n: (name) =>
      `https://github.com/eslint-community/eslint-plugin-n/blob/master/docs/rules/${name}.md`,
    'no-catch-all': () => `https://github.com/buschtoens/eslint-plugin-no-catch-all`,
    prettier: () => `https://github.com/prettier/eslint-plugin-prettier`,
    promise: (name) =>
      `https://github.com/eslint-community/eslint-plugin-promise/blob/main/docs/rules/${name}.md`,
    react: (name) =>
      `https://github.com/jsx-eslint/eslint-plugin-react/blob/master/docs/rules/${name}.md`,
    security: (name) =>
      `https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/rules/${name}.md`,
    vue: (name) => `https://eslint.vuejs.org/rules/${name}.html`,
    yml: (name) => `https://ota-meshi.github.io/eslint-plugin-yml/rules/${name}.html`,
  }

  // Built-in eslint rules (no prefix)
  if (!rule.includes('/')) {
    return `https://eslint.org/docs/latest/rules/${rule}`
  }

  // Find matching prefix
  for (const [prefix, fn] of Object.entries(urlMap)) {
    if (rule.startsWith(prefix + '/')) {
      const name = rule.slice(prefix.length + 1)
      return fn(name)
    }
  }

  return null
}

// Group rules by plugin prefix
const groups = new Map<string, [string, RuleEntry][]>()

for (const [rule, entry] of Object.entries(rules)) {
  const slashIndex = rule.indexOf('/')
  const prefix = slashIndex > 0 ? rule.substring(0, slashIndex) : 'eslint'

  // Handle scoped packages like @eslint-community/eslint-comments
  let groupKey: string
  if (rule.startsWith('@')) {
    const secondSlash = rule.indexOf('/', slashIndex + 1)
    groupKey = secondSlash > 0 ? rule.substring(0, secondSlash) : rule.substring(0, slashIndex)
  } else {
    groupKey = prefix
  }

  const existing = groups.get(groupKey)
  if (existing) {
    existing.push([rule, entry])
  } else {
    groups.set(groupKey, [[rule, entry]])
  }
}

// Generate markdown files per plugin in docs/
const docsDir = resolve(rootDir, 'docs')
await rm(docsDir, { recursive: true, force: true })
await mkdir(docsDir, { recursive: true })

const indexLines: string[] = [
  '# Rules',
  '',
  'This file is auto-generated by `npm run generate-rules-md`.',
  '',
]

for (const [group, entries] of groups) {
  const fileName = `${group.replace(/\//g, '_').replace(/^@/, '')}.md`

  const lines: string[] = [
    `# ${group}`,
    '',
    'This file is auto-generated by `npm run generate-rules-md`.',
    '',
    '| Rule | Severity | Exceptions |',
    '| --- | --- | --- |',
  ]

  for (const [rule, entry] of entries) {
    const url = getDocUrl(rule)
    const ruleCol = url ? `[${rule}](${url})` : rule

    // Build severity column - include files restriction if present
    let severityCol = `\`${entry.severity.toString()}\``
    if (entry.files && entry.files.length > 0) {
      const filesStr = entry.files.map((f) => `\`${f}\``).join(', ')
      severityCol += ` (${filesStr})`
    }

    // Build exceptions column
    let exceptionsCol = ''
    if (entry.exceptions && entry.exceptions.length > 0) {
      const parts = entry.exceptions.map((ex) => {
        const files = ex.files.map((f) => `\`${f}\``).join(', ')
        return `${ex.severity.toString()}: ${files}`
      })
      exceptionsCol = parts.join('<br>')
    }

    lines.push(`| ${ruleCol} | ${severityCol} | ${exceptionsCol} |`)
  }

  lines.push('')

  // eslint-disable-next-line security/detect-non-literal-fs-filename -- path is derived from rules.json keys, not user input
  await writeFile(resolve(docsDir, fileName), lines.join('\n'))
  const active = entries.filter(([, e]) => e.enabled).length
  indexLines.push(
    `- [${group}](docs/${fileName}) (${active.toString()}/${entries.length.toString()})`,
  )
}

indexLines.push('')

const rulesMarkdownPath = resolve(rootDir, 'RULES.md')
await writeFile(rulesMarkdownPath, indexLines.join('\n'))
// eslint-disable-next-line no-console
console.log('RULES.md and docs/ generated')
